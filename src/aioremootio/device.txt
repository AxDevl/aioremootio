from .constants import CONNECTION_OPTION_KEY_IP_ADDRESS
from .constants import CONNECTION_OPTION_KEY_API_SECRET_KEY
from .constants import CONNECTION_OPTION_KEY_API_AUTH_KEY
from .constants import PING_SENDER_HEARTBEAT
from .enums import ClientState
from .enums import DeviceState
from .errors import RemootioClientError
from .models import ConnectionOptions
from typing import List, Optional, Union
import aiohttp
import asyncio
import json
import logging


class RemootioDevice:
    """
    Class whose instances represents Remootio devices.
    """

    __client_session: aiohttp.ClientSession
    __connection_options: ConnectionOptions
    __logger: logging.Logger
    __ip_address: str
    __api_version: Optional[int]
    __serial_number: Optional[str]
    __uptime: Optional[int]
    __state: DeviceState
    __authenticated: bool
    __in_authentication_flow: bool
    __authentication_failed: Optional[bool]
    __authentication_query_id: Optional[int]
    __ws: Optional[aiohttp.ClientWebSocketResponse]
    __handle_messages: Optional[bool]
    __message_handler_running: bool
    __send_pings: Optional[bool]
    __ping_sender_running: bool
    __session_key: Optional[str]
    __last_action_id: Optional[int]
    __sent_action_ids: List
    __client_state: ClientState

    @classmethod
    async def create(
            cls,
            client_session: aiohttp.ClientSession,
            connection_options: Union[ConnectionOptions, dict],
            logger: Optional[logging.Logger] = None
    ):
        """
        Creates an :class:`RemootioDevice` instance.

        :param client_session:
        :type client_session: :class:`aiohttp.ClientSession`
        :param connection_options:
        :type connection_options: :class:`aioremootio.models.ConnectionOptions` or dict
        :param logger:
        :return: the created instance
        :rtype: :class:`RemootioDevice`
        """
        if type(connection_options) is dict:
            connection_option_keys = [
                CONNECTION_OPTION_KEY_IP_ADDRESS,
                CONNECTION_OPTION_KEY_API_SECRET_KEY,
                CONNECTION_OPTION_KEY_API_AUTH_KEY
            ]

            for connection_option_key in connection_option_keys:
                if connection_option_key not in connection_options:
                    raise ValueError(f"Option not defined: {connection_option_key}")

            connection_options = ConnectionOptions(
                connection_options[CONNECTION_OPTION_KEY_IP_ADDRESS],
                connection_options[CONNECTION_OPTION_KEY_API_SECRET_KEY],
                connection_options[CONNECTION_OPTION_KEY_API_AUTH_KEY]
            )

        if logger is None:
            logger = logging.getLogger(__name__)

        instance = cls(client_session, connection_options, logger)
        return instance

    def __init__(
            self,
            client_session: aiohttp.ClientSession,
            connection_options: ConnectionOptions,
            logger: logging.Logger
    ):
        self.__client_session = client_session
        self.__connection_options = connection_options
        self.__logger = logger
        self.__ip_address = self.__connection_options.ip_address
        self.__api_version = None
        self.__serial_number = None
        self.__uptime = None
        self.__state = DeviceState.UNKNOWN
        self.__authenticated = False
        self.__in_authentication_flow = False
        self.__authentication_failed = None
        self.__authentication_query_id = None
        self.__ws = None
        self.__handle_messages = None
        self.__message_handler_running = False
        self.__send_pings = None
        self.__ping_sender_running = False
        self.__session_key = None
        self.__last_action_id = None
        self.__sent_action_ids = []
        self.__client_state = ClientState.UNKNOWN

    async def __aenter__(self):
        await self.initialize()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.terminate()

    async def initialize(self) -> None:
        self.__logger.info("Initializing client...")

        await self.__connect_to_device()
        await self.start_message_handler()
        await self.__authenticate()

        if self.__api_version is None:
            await self.__send({"type": "HELLO"})

        await self.start_ping_sender()

        self.__client_state = ClientState.INITIALIZED

        self.__logger.info("Client has been initialized successfully.")

    async def terminate(self) -> None:
        self.__logger.info("Terminating client...")

        await self.__reset()

        self.__logger.info("Client has been terminated successfully.")

    @property
    def ping_sender_running(self) -> bool:
        return self.__ping_sender_running

    async def start_ping_sender(self) -> None:
        if not self.__ping_sender_running:
            self.__logger.debug("Making attempt to start the PING sender...")
            self.__send_pings = True
            await self.__execute_ping_sender()
        else:
            self.__logger.info("The PING sender is already running.")

    async def stop_ping_sender(self) -> None:
        if self.__ping_sender_running:
            self.__logger.debug("Making attempt to stop the PING sender...")
            try:
                await asyncio.wait_for(self.__stop_ping_sender(), 5 * PING_SENDER_HEARTBEAT)
            except TimeoutError:
                self.__logger.warning("The attempt to stop the PING sender has been timed out.")
            except:
                self.__logger.exception("The PING sender can't be stopped because of an error.")
        else:
            self.__logger.info("The PING sender is already stopped.")

    @property
    def message_handler_running(self) -> bool:
        return self.__message_handler_running

    async def start_message_handler(self) -> None:
        if not self.__message_handler_running:
            self.__logger.debug("Making attempt to start the Message handler...")
            self.__handle_messages = True
            await self.__execute_message_handler()
        else:
            self.__logger.info("The Message handler is already running.")

    async def stop_message_handler(self) -> None:
        if self.__message_handler_running:
            self.__logger.debug("Making attempt to stop the Message handler...")
            try:
                await asyncio.wait_for(self.__stop_message_handler(), 5 * self.__connection_options.heartbeat)
            except TimeoutError:
                self.__logger.warning("The attempt to stop the Message handler has been timed out.")
            except:
                self.__logger.exception("The Message handler can't be stopped because of an error.")
        else:
            self.__logger.info("The Message handler is already stopped.")

    @property
    def connected(self) -> bool:
        return self.__ws is not None and not self.__ws.closed

    @property
    def authenticated(self) -> bool:
        return self.__authenticated and not self.__authentication_failed and self.__session_key is not None

    @property
    def initialized(self) -> bool:
        return self.connected and self.authenticated and self.__ping_sender_running and \
               self.__message_handler_running and self.api_version is not None

    @property
    def ip_address(self) -> Optional[str]:
        return self.__ip_address

    @property
    def api_version(self) -> Optional[int]:
        return self.__api_version

    @property
    def serial_number(self) -> Optional[str]:
        return self.__serial_number

    @property
    def uptime(self) -> Optional[int]:
        return self.__uptime

    @property
    def state(self) -> Optional[DeviceState]:
        return self.__state

    @property
    def sensor_installed(self) -> Optional[bool]:
        result = None

        if self.state is not None and self.state != DeviceState.UNKNOWN:
            result = self.state != DeviceState.NO_SENSOR_INSTALLED

        return result

    async def __connect_to_device(self) -> None:
        # TODO: Make more attempts to connect
        try:
            self.__ws = await self.__client_session.ws_connect(f"ws://{self.__connection_options.ip_address}:8080/")
            self.__logger.info("Client has been connected to the device.")
        except aiohttp.ClientConnectionError:
            self.__logger.exception("Client is unable to establish connection to the device.")
            raise
        except:
            self.__logger.exception("Client is unable to establish connection to the device.")
            raise

    async def __authenticate(self) -> None:
        self.__in_authentication_flow = True

        # Reset members set during authentication
        self.__authenticated = False
        self.__authentication_failed = None
        self.__last_action_id = None
        self.__session_key = None

        try:
            await self.__send({"type": "AUTH"})
            await asyncio.sleep(10 * self.__connection_options.heartbeat)

            if self.authenticated:
                self.__logger.info("Client was successfully authenticated by the device.")
            elif self.__authentication_failed:
                raise RemootioClientError(
                    self,
                    "Client can't be authenticated by the device because of an authentication failure.")
            else:
                raise RemootioClientError(self, "Client can't be authenticated by the device.")
        except RemootioClientError as e:
            self.__logger.error(e.message)
            raise
        except BaseException:
            self.__logger.exception("Client can't be authenticated by the device because of an error.")
            raise
        finally:
            self.__in_authentication_flow = False

    async def __execute_ping_sender(self) -> None:
        self.__ping_sender_running = True
        self.__logger.info("The PING sender has been started successfully.")

        error_occurred = False

        try:
            while self.__send_pings:
                await self.__reconnect_if_needed()
                await self.__send({"type": "PING"})
                await asyncio.sleep(PING_SENDER_HEARTBEAT)
        except BaseException:
            self.__logger.exception("Error occurred during executing the PING sender.")
            error_occurred = True
            raise
        finally:
            self.__ping_sender_running = False
            self.__send_pings = False
            if error_occurred:
                self.__logger.error("The PING sender has been stopped because of an error.")
            else:
                self.__logger.info("The PING sender has been stopped successfully.")

    async def __stop_ping_sender(self) -> None:
        self.__send_pings = False

        while self.__ping_sender_running:
            await asyncio.sleep(PING_SENDER_HEARTBEAT)

    async def __execute_message_handler(self) -> None:
        self.__message_handler_running = True
        self.__logger.info("The Message handler has been started successfully.")

        error_occurred = False

        try:
            while self.__handle_messages:
                await self.__reconnect_if_needed()

                async for msg in self.__ws:
                    try:
                        self.__logger.debug("Message received from device. Type [%s]", msg.type)

                        if msg.type == aiohttp.WSMsgType.TEXT:
                            frame = msg.json()
                            self.__logger.debug(f"< {json.dumps(frame)}")

                            frame_type = self.__retrieve_frame_type(frame)

                            if frame_type is None:
                                self.__logger.error("Failed to handle message. Unable to determine frame type.")
                            elif frame_type == "ERROR":
                                await self.__handle_error_frame(frame)
                            elif frame_type == "PONG":
                                pass
                            elif frame_type == "SERVER_HELLO":
                                await self.__handle_server_hello_frame(frame)
                            elif frame_type == "ENCRYPTED":
                                await self.__handle_encrypted_frame(frame)
                            else:
                                self.__logger.error(
                                    "Failed to handle message. Frame of type isn't supported. FrameType [%s]",
                                    frame_type
                                )
                        elif msg.type == aiohttp.WSMsgType.BINARY:
                            self.__logger.warning("Binary messages aren't supported.")
                        elif msg.type == aiohttp.WSMsgType.CLOSE:
                            self.__logger.info("Connection was closed.")
                            await self.__reset(False)
                        elif msg.type == aiohttp.WSMsgType.PING:
                            await self.__ws.pong()
                        elif msg.type == aiohttp.WSMsgType.PONG:
                            pass
                        else:
                            pass
                    except BaseException:
                        self.__logger.exception("Failed to handle message.")
                else:
                    await asyncio.sleep(self.__connection_options.heartbeat)
        except BaseException:
            self.__logger.exception("Error occurred during executing the Message handler.")
            error_occurred = True
            raise
        finally:
            self.__message_handler_running = False
            self.__handle_messages = False
            if error_occurred:
                self.__logger.error("The Message handler has been stopped because of an error.")
            else:
                self.__logger.info("The Message handler has been stopped successfully.")

    async def __stop_message_handler(self) -> None:
        self.__handle_messages = False

        while self.__message_handler_running:
            await asyncio.sleep(self.__connection_options.heartbeat)

    async def __handle_error_frame(self, frame) -> None:
        if "errorMessage" in frame:
            if frame["errorMessage"] == "json error":
                self.__logger.error(
                    "Error received from device. Device couldn't parse the received frame as JSON object."
                )
            elif frame["errorMessage"] == "input error":
                self.__logger.error(
                    "Error received from device. Device could parse the received frame as JSON object, "
                    "but the values in it do not correspond to any valid Remootio API frame."
                )
            elif frame["errorMessage"] == "internal error":
                self.__logger.error(
                    "Error received from device. The device encountered an internal error."
                )
            elif frame["errorMessage"] == "connection timeout":
                # If the device doesn't receive a frame from the client for 120 seconds, then it send an error frame
                # with this message and closes the connection.

                self.__logger.error(
                    "Error received from device. The device raised an connection timeout."
                )

                await self.__reset()
            elif frame["errorMessage"] == "authentication timeout":
                # The device closes any unauthenticated session after 30 seconds and sends an error frame with this
                # message.

                self.__logger.error(
                    "Error received from device. The device raised an authentication timeout."
                )

                await self.__reset()
            elif frame["errorMessage"] == "already authenticated":
                self.__logger.warning(
                    "Error received from device. The device reported back, that the session is already authenticated."
                )

                self.__authenticated = True
            elif frame["errorMessage"] == "authentication error":
                # The device send an error frame with this message if an error occurs during the authentication of
                # the client or an action was initiated with an invalid action id.

                self.__logger.error(
                    "Error received from device. The device raised an authentication error."
                )

                if self.__in_authentication_flow:
                    self.__authentication_failed = True
                else:
                    await self.__reset(False)

    async def __handle_server_hello_frame(self, frame) -> None:
        self.__api_version = int(frame["apiVersion"])
        if "serialNumber" in frame:
            self.__serial_number = str(frame["serialNumber"])

    async def __handle_encrypted_frame(self, frame) -> None:
        if "data" not in frame or "mac" not in frame:
            raise RemootioClientError(self, "Received frame appears to be invalid.")
        elif "iv" not in frame["data"] or "payload" not in frame["data"]:
            raise RemootioClientError(self, "Received frame appears to be invalid.")

        decrypted_frame = await self.__decrypt_frame(frame)

        if "challenge" in decrypted_frame and self.__in_authentication_flow:
            self.__last_action_id = int(decrypted_frame["challenge"]["initialActionId"])
            self.__session_key = decrypted_frame["challenge"]["sessionKey"]

            self.__authentication_query_id = (self.__retrieve_next_action_id() % 0x7FFFFFFF)

            await self.__encrypt_and_send({
                "action": {
                    "type": "QUERY",
                    "id": self.__authentication_query_id
                }
            })
        elif "response" in decrypted_frame:
            response_id = decrypted_frame["response"]["id"]
            device_current_uptime = (decrypted_frame["response"]["t100ms"] * 100) / 1000

            self.__synchronize_uptime(device_current_uptime)

            if response_id in self.__sent_action_ids:
                self.__handle_response(decrypted_frame["response"], True)

                self.__sent_action_ids.remove(response_id)
            else:
                self.__handle_response(decrypted_frame["response"], False)
        elif "event" in decrypted_frame:
            # TODO
            pass

    def __handle_response(self, response, belongs_to_client_initiated_action: bool):
        response_type = response["type"]
        response_id = response["id"]
        action_succeeded = response["success"]
        device_relay_triggered = response["relayTriggered"]
        device_current_state = self.__to_device_state(response["state"])

        if not action_succeeded:
            error_code = ""
            if "errorCode" in response:
                error_code = response["errorCode"]

            if belongs_to_client_initiated_action:
                self.__logger.error(
                    "Device has failed to perform a through the client initiated action. Id [%s] Type [%s] "
                    "ErrorCode [%s]",
                    response_id,
                    response_type,
                    error_code
                )
            else:
                self.__logger.error(
                    "Device has failed to perform a not through the client initiated action. Id [%s] Type [%s] "
                    "ErrorCode [%s]",
                    response_id,
                    response_type,
                    error_code
                )

            # TODO: Call listener for failed actions if set
        elif response_type == "QUERY":
            if self.__in_authentication_flow and self.__authentication_query_id == response_id:
                self.__change_state(device_current_state)
                self.__authenticated = True
                self.__authentication_failed = False
            else:
                self.__synchronize_state(device_current_state)

            if belongs_to_client_initiated_action:
                self.__logger.info(
                    "Device has successfully performed a through the client initiated action. Id [%s] Type [%s] "
                    "RelayTriggered [%s]",
                    response_id,
                    response_type,
                    device_relay_triggered
                )
            else:
                self.__logger.info(
                    "Device has successfully performed a not through the client initiated action. Id [%s] Type [%s] "
                    "RelayTriggered [%s]",
                    response_id,
                    response_type,
                    device_relay_triggered
                )
        else:
            self.__synchronize_state(device_current_state)

            if belongs_to_client_initiated_action:
                self.__logger.info(
                    "Device has successfully performed a through the client initiated action. Id [%s] Type [%s] "
                    "RelayTriggered [%s]",
                    response_id,
                    response_type,
                    device_relay_triggered
                )
            else:
                self.__logger.info(
                    "Device has successfully performed a not through the client initiated action. Id [%s] Type [%s] "
                    "RelayTriggered [%s]",
                    response_id,
                    response_type,
                    device_relay_triggered
                )

    async def __send(self, frame) -> None:
        await self.__ws.send_json(frame)
        self.__logger.debug(f"> {json.dumps(frame)}")

    async def __encrypt_and_send(self, frame) -> None:
        encrypted_frame = await self.__encrypt_frame(frame)
        await self.__send(encrypted_frame)
        if "action" in frame:
            self.__sent_action_ids.append(frame["action"]["id"])
            self.__logger.info(
                "Device action initiated through client. Id [%s] Type [%s]",
                frame["action"]["id"],
                frame["action"]["type"]
            )

    def __retrieve_frame_type(self, frame) -> str:
        result = None

        if type(frame) is dict and "type" in frame:
            result = frame["type"]

        return result

    def __retrieve_next_action_id(self) -> int:
        if self.__last_action_id is None:
            raise RemootioClientError(self, "Unable to retrieve next action id.")

        self.__last_action_id = self.__last_action_id + 1
        return self.__last_action_id

    async def __reset(self, hard: bool = True) -> None:
        if self.connected:
            try:
                await self.__ws.close()
                self.__logger.info("Connection to the device has been closed.")
            except:
                self.__logger.exception("Connection to the device can't closed because of an error.")

        self.__authenticated = False
        self.__in_authentication_flow = False
        self.__authentication_failed = None
        self.__authentication_query_id = None
        self.__ws = None
        self.__session_key = None
        self.__last_action_id = None
        self.__sent_action_ids = []
        self.__client_state = ClientState.UNKNOWN

        if hard:
            self.__api_version = None
            self.__serial_number = None
            self.__uptime = None
            self.__state = DeviceState.UNKNOWN

            await self.stop_ping_sender()
            await self.stop_message_handler()

        self.__logger.info("Client has been reset.")

    async def __reconnect_if_needed(self) -> None:
        if self.__ws is None or self.__ws.closed:
            if self.__client_state != DeviceState.UNKNOWN:
                self.__logger.debug("Client needs to be reset.")
                await self.__reset()

            self.__logger.debug("Client needs to be reinitialized.")
            await self.initialize()

    def __to_device_state(self, state: str) -> DeviceState:
        result = DeviceState.UNKNOWN

        if state.lower() == "open":
            result = DeviceState.OPEN
        elif state.lower() == "closed":
            result = DeviceState.CLOSED
        elif state.lower() == "no sensor":
            result = DeviceState.NO_SENSOR_INSTALLED

        return result

    def __encrypt_frame(self, frame: dict) -> dict:
        frame_str = json.dumps(frame)
